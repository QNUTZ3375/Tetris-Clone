/* autogenerated by Processing revision 1293 on 2024-04-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Arrays;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Tetris_Clone_attempt extends PApplet {


boolean left, right, down;
int cellSize = 40;
int xStartPos = 250;
int yStartPos = -100;
int heightLimit = 4;
int cols = 10;
int rows = 20 + heightLimit;
int softDropRate = 30; //out of 60, 0 being slow, 60 being fast
int pieceDropRate = 0;
int pieceDropLimit = 120; //Default is 60, decrease for harder difiiculty
int playerScore = 0;
int playerLines = 0;
int playerLevel = 1;
int[] pointsTable = {40, 100, 300, 1200};
boolean hasSwitched = false;
boolean isGameOver = false;
int[] sevenBagRandomizer = {0, 1, 2, 3, 4, 5, 6};
Mino[][] grid = new Mino[cols][rows];
int[][] TCoords = {{4, 3}, {3, 4}, {4, 4}, {5, 4}};
int[][] ICoords = {{3, 4}, {4, 4}, {5, 4}, {6, 4}};
int[][] OCoords = {{4, 3}, {5, 3}, {4, 4}, {5, 4}};
int[][] JCoords = {{3, 3}, {3, 4}, {4, 4}, {5, 4}};
int[][] LCoords = {{5, 3}, {5, 4}, {4, 4}, {3, 4}};
int[][] SCoords = {{5, 3}, {4, 3}, {4, 4}, {3, 4}};
int[][] ZCoords = {{3, 3}, {4, 3}, {4, 4}, {5, 4}};
Tetromino[] piecesInPlay = new Tetromino[5]; //Index 0 is the current piece falling, 1 is the held piece, 2 and onwards are next pieces
PFont f;
PFont r;
int arrLimit = 3;
int arrCounter = 0;
int dasLimit = 5;
int dasCounter = 0;

//Draws the grid
public void drawGrid(){
  for(int i = 0; i < cols; i++){
    for(int j = heightLimit; j < rows; j++){
      grid[i][j].show();
    }
  }
}

//Checks if the next piece spawned is in a valid position
public boolean checkSpawnState(int startCol, int endCol){
  for(int i = startCol; i < endCol; i++){
    if (grid[i][heightLimit - 1].isSolid){
      return true;
    }
  }
  return false;
}

//Spews out a random number from 0 - 6 with 7-bag constraints (helps with generation of the next piece)
public int randomizerFunction(){
  int returnVal;
  if(sevenBagRandomizer.length > 1){
    int r = PApplet.parseInt(random(0, sevenBagRandomizer.length));
    returnVal = sevenBagRandomizer[r];
    for(int i = r; i < sevenBagRandomizer.length - 1; i++){
      sevenBagRandomizer[i] = sevenBagRandomizer[i + 1];
    }
    sevenBagRandomizer = Arrays.copyOf(sevenBagRandomizer, sevenBagRandomizer.length - 1);
  } else{
    returnVal = sevenBagRandomizer[0];
    sevenBagRandomizer = Arrays.copyOf(sevenBagRandomizer, 7);
    for(int i = 0; i < sevenBagRandomizer.length; i++){
      sevenBagRandomizer[i] = i;
    }
  }
  return returnVal;
}

public void updateMetrics(int[] linesCleared){
  //adds up the score and lines cleared after clearing the lines
  playerScore += pointsTable[linesCleared.length - 1] * playerLevel;
  playerLines += linesCleared.length;
  playerLevel = (playerLines / 10) + 1;
  //Difficulty calculation
  if (playerLevel < 12){
    pieceDropLimit = 60 - 5*(playerLevel - 1);
  } else{
    if(playerLevel < 15){
      pieceDropLimit = 10 - (playerLevel % 10);
    } else if(playerLevel < 18 ){
      pieceDropLimit = 4;
    } else if(playerLevel < 19){
      pieceDropLimit = 3;
    } else if(playerLevel < 29){
      pieceDropLimit = 2;
    } else{
      pieceDropLimit = 1;
    }
  }
}

//Scans the board for full lines
public void checkLineClears(){
  int[] linesCleared = {};
  int initialFullLine = -1;
  //Goes through all the playable rows
  for(int i = rows - 1; i >= heightLimit; i--){
    //Goes through each column in a row
    for(int j = 0; j < cols; j++){
      if(!grid[j][i].isSolid){    //Case where a cell in a column is not filled
        break;
      } else if(j == cols - 1){    //Case where all the columns are filled
        initialFullLine = i;
        //appends initialFullLine's value into linesCleared, making it contain 1 line to be cleared
        linesCleared = Arrays.copyOf(linesCleared, linesCleared.length + 1);
        linesCleared[0] = i;
      }
    }
    //Checks if there is a full row filled
    if(initialFullLine != -1){
      break;
    }
  }
  
  //checks if there is at least one row fully filled
  if(initialFullLine != -1){
    //Goes through all the rows starting directly above initialFullLine (only checks 3 lines above it as the first one is already found)
    for(int i = initialFullLine - 1; i > initialFullLine - 4; i--){
      //Goes through each column in a row
      for(int j = 0; j < cols; j++){
        if(!grid[j][i].isSolid){    //Case where a cell in a column is not filled
          break;
        } else if(j == cols - 1){    //Case where all the columns are filled
          //Appends the current row to linesCleared
          linesCleared = Arrays.copyOf(linesCleared, linesCleared.length + 1);
          linesCleared[linesCleared.length - 1] = i;
        }
      }
    }
    updateMetrics(linesCleared);
  }
  
  //Goes through each row in linesCleared
  for(int j = linesCleared.length - 1; j > -1; j--){
    //Goes through all columns
    for(int i = 0; i < cols; i++){
      //Resets the Minos of the cleared line to their default state
      grid[i][linesCleared[j]].resetValues();
      
      //Goes through all the rows above the line just cleared (at column i) except for row 0
      for(int k = linesCleared[j]; k > 1; k--){
        grid[i][k].copyMinoValues(grid[i][k - 1]);
      }
      //Resets the Mino at column i and row 0 back to default state
      grid[i][0].resetValues();
    }
  }
}

//The code for the "NEXT" section
public void showNextPiece(){
  fill(200);
  stroke(0);
  strokeWeight(1);
  rect(675, 150, 200, 600);
  fill(0);
  textFont(f, 40);
  text("NEXT", 720, 140);
  for(int i = 2; i < piecesInPlay.length; i++){
    if(piecesInPlay[i] instanceof Tetromino){
      if(piecesInPlay[i] instanceof I_Piece){
        piecesInPlay[i].showOutsideGrid(575, 68 + (i - 2)*200);
      }
      else if(piecesInPlay[i] instanceof O_Piece){
        piecesInPlay[i].showOutsideGrid(575, 88 + (i - 2)*200);
      } else{
        piecesInPlay[i].showOutsideGrid(593, 90 + (i - 2)*200);
      }
    }
  }
}

//The code for the "HOLD" section
public void showHeldPiece(){
  fill(200);
  stroke(0);
  strokeWeight(1);
  square(25, 150, 200);
  fill(0);
  textFont(f, 40);
  text("HOLD", 70, 140);
  if(piecesInPlay[1] instanceof Tetromino){
    if(piecesInPlay[1] instanceof I_Piece){
      piecesInPlay[1].showOutsideGrid(-75, 68);
    }
    else if(piecesInPlay[1] instanceof O_Piece){
      piecesInPlay[1].showOutsideGrid(-75, 88);
    } else{
      piecesInPlay[1].showOutsideGrid(-57, 90);
    }
  }
}

public void showPlayerScoreAndLinesAndDifficulty(){
  fill(0);
  textFont(f, 40);
  text("SCORE: \n" + playerScore, 45, 450);
  text("LINES: \n" + playerLines, 45, 600);
  text("LEVEL: \n" + playerLevel, 45, 750);
}

public void getNewPiece(){
  piecesInPlay[0] = piecesInPlay[2];
  for(int i = 2; i < piecesInPlay.length - 1; i++){
    piecesInPlay[i] = piecesInPlay[i + 1];
  }
  //Generates a new piece
  switch(randomizerFunction()){
    case 0:
      piecesInPlay[piecesInPlay.length - 1] = new T_Piece(TCoords);
      break;
    case 1:
      piecesInPlay[piecesInPlay.length - 1] = new O_Piece(OCoords);
      break;
    case 2:
      piecesInPlay[piecesInPlay.length - 1] = new I_Piece(ICoords);
      break;
    case 3:
      piecesInPlay[piecesInPlay.length - 1] = new J_Piece(JCoords);
      break;
    case 4:
      piecesInPlay[piecesInPlay.length - 1] = new L_Piece(LCoords);
      break;
    case 5:
      piecesInPlay[piecesInPlay.length - 1] = new S_Piece(SCoords);
      break;
    case 6:
      piecesInPlay[piecesInPlay.length - 1] = new Z_Piece(ZCoords);
      break;
    default:
      piecesInPlay[piecesInPlay.length - 1] = null;
  }
  //Checks if the piece can spawn into the grid
  if(piecesInPlay[0] instanceof I_Piece){
    isGameOver = checkSpawnState(3, 7);
  } else if (piecesInPlay[0] instanceof O_Piece){
    isGameOver = checkSpawnState(4, 6);
  } else{
    isGameOver = checkSpawnState(3, 6);
  }
}

public void removeCurrentPiece(){
  //Converts current piece into the grid and removes the piece from the board
  for(Mino p: piecesInPlay[0].pieces){
    grid[p.x][p.y].isSolid = true;
    grid[p.x][p.y].r = p.r;
    grid[p.x][p.y].g = p.g;
    grid[p.x][p.y].b = p.b;
  }
  //Derefereces the current piece to prevent movement
  piecesInPlay[0] = null;
  hasSwitched = false;
}

public void switchWithHeldPiece(){
  if(!hasSwitched){
    hasSwitched = true;
    piecesInPlay[0].resetPosition();
    if(piecesInPlay[1] instanceof Tetromino){
      Tetromino tempRef = piecesInPlay[1];
      piecesInPlay[1] = piecesInPlay[0];
      piecesInPlay[0] = tempRef;
      piecesInPlay[0].resetPosition();
    } else{
      piecesInPlay[1] = piecesInPlay[0];
      getNewPiece();
    }
  }
}

public void showGhostPiece(Tetromino currPiece){
  int yDist = rows - 1;
  //Finds the Mino on the piece with the lowest Y value
  for(Mino p: currPiece.pieces){ //finds the smallest distance between the piece and the "floor" (not only the floor)
    int currLowestNonSolidY = p.y;
    //checks each row if the current cell is not solid (starts from the cell directly below it)
    for(int i = p.y + 1; i < rows; i++){  
      if (!grid[p.x][i].isSolid){
        currLowestNonSolidY++;
      } else{
        break;
      }
    }
    yDist = min(yDist, currLowestNonSolidY - p.y); //takes the smallest distance available
  }
  
  for(Mino p: currPiece.pieces){
    fill(p.r - 55, p.g - 55, p.b - 55, 125);
    square(xStartPos + p.x*cellSize, yStartPos + (p.y + yDist)*cellSize, cellSize);
  }
}

public void setup(){
  /* size commented out by preprocessor */;
  //Initializes grid
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      grid[i][j] = new Mino(i, j);
    }
  }
  f = createFont("Helvetica", 40, true);
  r = createFont("Zapfino", 12, true);
}

public void draw(){
  background(125);
  drawGrid();
  showNextPiece();
  showHeldPiece();
  showPlayerScoreAndLinesAndDifficulty();
  textFont(r, 12);
  fill(255);
  text("Made By: Jozka N.T. \n       (in 3 Days)", 685, 800);
  //Checks if current piece is tetromino and is not game over
  if(!isGameOver){
    if (piecesInPlay[0] instanceof Tetromino){
      showGhostPiece(piecesInPlay[0]);
      piecesInPlay[0].show();
      if(left){
        if(arrCounter >= arrLimit && dasCounter >= dasLimit){
          arrCounter = 0;
          right = false;
          piecesInPlay[0].moveLeft();
        }else if(dasCounter >= dasLimit){
          arrCounter++;
        }else{
          dasCounter++;
        }
      }
      if(right){
        if(arrCounter >= arrLimit && dasCounter >= dasLimit){
          arrCounter = 0;
          left = false;
          piecesInPlay[0].moveRight();
        }else if(dasCounter >= dasLimit){
          arrCounter++;
        }else{
          dasCounter++;
        }
      }
      if(down){
        if(arrCounter >= arrLimit){
          arrCounter = 0;
          piecesInPlay[0].softDrop();
        }else{
          arrCounter++;
        }
      }
      //Checks if countdown for moving piece has expired
      if(pieceDropRate >= pieceDropLimit){
        piecesInPlay[0].update();
        pieceDropRate = 0;
        //Checks if current piece has locked in place
        if (piecesInPlay[0].isLocked){
          removeCurrentPiece();
        }
      } else{
        pieceDropRate++;
      }
    } else{
      checkLineClears();
      getNewPiece();
    }
  } else{
    for(int i = 0; i < cols; i++){
      for(int j = 0; j < rows; j++){
        if(!(grid[i][j].r == 0 && grid[i][j].g == 0 && grid[i][j].b == 0)){
          grid[i][j].setColor(55, 55, 55);
        }
      }
    }
    fill(255);
    rect(270, 400, 360, 120);
    textFont(f, 40);
    fill(0);
    text("Press any key\n   to restart!", 320, 450);
  }
}

public void keyPressed(){
  if (piecesInPlay[0] instanceof Tetromino && !isGameOver){
    if(keyCode == RIGHT){
      piecesInPlay[0].moveRight();
      right = true;
    }
    if (keyCode == LEFT){
      piecesInPlay[0].moveLeft();
      left = true;
    }
    if (keyCode == DOWN){
      down = true;
    }
    if (keyCode == UP){
      switchWithHeldPiece();
    }
    if (key == ' '){
      piecesInPlay[0].hardDrop();
    }
    if (key == 'c'){
      piecesInPlay[0].rotateCW();
    }
    if (key == 'x'){
      piecesInPlay[0].rotateCCW();
    }
  } else if(isGameOver){
    piecesInPlay = new Tetromino[5];
    pieceDropLimit = 60;
    playerScore = 0;
    playerLines = 0;
    playerLevel = 1;
    sevenBagRandomizer = Arrays.copyOf(sevenBagRandomizer, 7);
    for(int i = 0; i < sevenBagRandomizer.length; i++){
      sevenBagRandomizer[i] = i;
    }  
    for(int i = 0; i < cols; i++){
      for(int j = 0; j < rows; j++){
        grid[i][j].resetValues();
      }
    }
    isGameOver = false;
  }
}

public void keyReleased(){
  if(keyCode == RIGHT){
    dasCounter = 0;
    arrCounter = 0;
    right = false;
  }
  if(keyCode == LEFT){
    dasCounter = 0;
    arrCounter = 0;
    left = false;
  }
  if(keyCode == DOWN){
    arrCounter = 0;
    down = false;
  }
}

/*
Notes:
- 20 Dec: Started this project, made Mino class, Tetromino class, T Piece class
- 20 Dec: added softdrop, harddrop, moveleft, moveright, and a bunch of helper functions
- 20 Dec: fixed a bug where harddropping caused an indexOutOfBounds error (recounted the same cell twice, off by one issue)
- 20 Dec: fixed collision detection so now it checks every piece instead of the lowest y piece
- 20 Dec: added clockwise and counterclockwise rotation to T piece, fixed a bug where pieces can move left or right into other pieces
- 20 Dec: extended the rows to 24 (only 20 are still playable) to prevent indexOutOfBounds errors when moving the piece at the top
- 20 Dec: Created the O Piece and I Piece, fixed a bug where a piece can lock in mid-air due to frantic spinning
- 20 Dec: improved an existing function which detects if a new piece can spawn in the board so now it checks the columns along with the rows

- 21 Dec: refactored code in the T piece from 200+ to 100+ lines, made the J, L, S, and Z piece using the T piece code as a template
- 21 Dec: refactored code in the I piece from around 220 to under 130 lines, added 7-bag randomization
- 21 Dec: added a line clear function, fixed over a dozen bugs that came with it
          (this function took the longest and was the most annoying to implement QAQ)

- 22 Dec: added Next box and Hold box, added scoring system, extended the next box to show next 3 pieces, added line cleared metric
- 22 Dec: added difficulty scaling, added ghost piece, added a restart mechanic, changes all pieces to gray when game over is triggered

THIS PROJECT IS NOW FINISHED: 1320 Lines of code in total (May modify it in the future if I feel like it);

Extras:
- 25 Jan: added DAS and ARR support (now pieces can move faster yay)
*/
class I_Piece extends Tetromino{
  /*For I piece: 
      State '0' and State '2':      State 'R' and State 'L':
      pieces[0] = Far left          pieces[0] = Top
      pieces[1] = Center left       pieces[1] = Middle top
      pieces[2] = Center Right      pieces[2] = Middle bottom
      pieces[3] = Far right         pieces[3] = Bottom
  */
  
  I_Piece(int[][] xyCoords){
    super(xyCoords);
    for(Mino p: pieces){
      p.setColor(0, 255, 255);
    }
  }
  
  public boolean isValidFutureState(int[][] futureState){
    for(int i = 0; i < futureState.length; i++){ //testing the current position
        if (futureState[i][0] < 0 || futureState[i][0] >= cols || futureState[i][1] < 0 || futureState[i][1] >= rows){
          return false;
        }
        if (grid[futureState[i][0]][futureState[i][1]].isSolid){
          return false;
        }
      }
    return true;
  }
  
  public void updateFutureStates(int[][] futureState){
    for(int i = 0; i < futureState.length; i++){ //updates state of all pieces
          pieces[i].x = futureState[i][0];
          pieces[i].y = futureState[i][1];
    }
  }
  
  public void switchStateToBeChecked(int[][] futureState, int xDisplacement, int yDisplacement){
    for(int i = 0; i < futureState.length; i++){ //switches future state position
        futureState[i][0] += xDisplacement;
        futureState[i][1] += yDisplacement;
    }
  }
  
  public boolean checkCurrentPosition(int[][] futureState, int xDisplacement, int yDisplacement){
    switchStateToBeChecked(futureState, xDisplacement, yDisplacement); //changes to the current position

    if (isValidFutureState(futureState)){ //checks if current position is valid
      updateFutureStates(futureState);
      return true;
    } else{
      return false;
    }
  } 

  public int[][] getState(String direction, char position){
    //(Note: I'm too lazy to code this in but I found this neat quirk);
    //CWSR = CCWS2 flipped
    //CWS2 = CCWSR flipped
    //CWSL = CCWS0 flipped
    //CWS0 = CCWSL flipped
    int[][] CWStateR = {{pieces[2].x, pieces[2].y - 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y + 1}, {pieces[2].x, pieces[2].y + 2}};
    int[][] CWState2 = {{pieces[2].x - 2, pieces[2].y}, {pieces[2].x - 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x + 1, pieces[2].y}};
    int[][] CWStateL = {{pieces[2].x - 1, pieces[2].y - 2}, {pieces[2].x - 1, pieces[2].y - 1}, {pieces[2].x - 1, pieces[2].y}, {pieces[2].x - 1, pieces[2].y + 1}};
    int[][] CWState0 = {{pieces[2].x - 1, pieces[2].y - 1}, {pieces[2].x, pieces[2].y - 1}, {pieces[2].x + 1, pieces[2].y - 1}, {pieces[2].x + 2, pieces[2].y - 1}};
    int[][] CCWStateL = {{pieces[2].x - 1, pieces[2].y - 1}, {pieces[2].x - 1, pieces[2].y}, {pieces[2].x - 1, pieces[2].y + 1}, {pieces[2].x - 1, pieces[2].y + 2}};
    int[][] CCWState2 = {{pieces[2].x - 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x + 1, pieces[2].y}, {pieces[2].x + 2, pieces[2].y}};
    int[][] CCWStateR = {{pieces[2].x, pieces[2].y - 2}, {pieces[2].x, pieces[2].y - 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y + 1}};
    int[][] CCWState0 = {{pieces[2].x - 2, pieces[2].y - 1}, {pieces[2].x - 1, pieces[2].y - 1}, {pieces[2].x, pieces[2].y - 1}, {pieces[2].x + 1, pieces[2].y - 1}};

    if(direction == "CW"){
      if(position == 'R'){
        return CWStateR;
      } else if(position == '2'){
        return CWState2;
      } else if(position == 'L'){
        return CWStateL;
      } else{
        return CWState0;
      }
    } else{
      if(position == 'L'){
        return CCWStateL;
      } else if(position == '2'){
        return CCWState2;
      } else if(position == 'R'){
        return CCWStateR;
      } else{
        return CCWState0;
      }
    }
  }
  
  public int[][] getDisplacement(String direction, char futurePosition){
    int[][] option1 = {{0, 0}, {-2, 0}, {3, 0}, {-3, 1}, {3, -3}};    //CWR = CCW2
    int[][] option2 = {{0, 0}, {-1, 0}, {3, 0}, {-3, -2}, {3, 3}};    //CW2 = CCWL
    int[][] option3 = {{0, 0}, {2, 0}, {-3, 0}, {3, -1}, {-3, 3}};    //CWL = CCW0
    int[][] option4 = {{0, 0}, {1, 0}, {-3, 0}, {3, 2}, {-3, -3}};    //CW0 = CCWR

    if((direction == "CW" && futurePosition == 'R') || (direction == "CCW" && futurePosition == '2')){
      return option1;
    } else if((direction == "CW" && futurePosition == '2') || (direction == "CCW" && futurePosition == 'L')){
      return option2;
    } else if((direction == "CW" && futurePosition == 'L') || (direction == "CCW" && futurePosition == '0')){
      return option3;
    } else{
      return option4;
    }
  }
  
  public void rotatePiece(String direction){
    int[][] futureState = getState(direction, allStates[currState]); //gets the future state of all of the pieces
    int[][] xyTests = getDisplacement(direction, allStates[currState]); //gets the displacements to test all positions of the future state
    
    for(int i = 0; i < xyTests.length; i++){
      if(checkCurrentPosition(futureState, xyTests[i][0], xyTests[i][1])){  //checks if any of the 5 test positions are valid
        return;
      }
    }
  }
  
  public void rotateCW(){
    currState = (currState + 1) % allStates.length;  //updates the current state of the piece
    rotatePiece("CW");
  }
    
  public void rotateCCW(){
    currState = (currState - 1 + allStates.length) % allStates.length;  //updates the current state of the piece
    rotatePiece("CCW");
  }
}
class J_Piece extends Tetromino{ 
  /*For J piece: 
      pieces[2] = Center
      
      State '0':                State 'R':                 State '2':                    State 'L':
      pieces[0] = Top left      pieces[0] = Top right      pieces[0] = Bottom right      pieces[0] = Bottom left
      pieces[1] = Left          pieces[1] = Top            pieces[1] = Right             pieces[1] = Bottom
      pieces[3] = Right         pieces[3] = Bottom         pieces[3] = Left              pieces[3] = Top
  */ 
  J_Piece(int[][] xyCoords){
    super(xyCoords);
    for(Mino p: pieces){
      p.setColor(0, 0, 255);
    }
  }
  
  public boolean isValidFutureState(int[][] tempStates){
    for(int i = 0; i < tempStates.length; i++){ //testing the current position
        if (tempStates[i][0] < 0 || tempStates[i][0] >= cols || tempStates[i][1] < 0 || tempStates[i][1] >= rows){
          return false;
        }
        if (grid[tempStates[i][0]][tempStates[i][1]].isSolid){
          return false;
        }
      }
    return true;
  }
  
  public void updateFutureStates(int[][] tempStates){
    for(int i = 0; i < tempStates.length; i++){ //updates state of all pieces
          pieces[i].x = tempStates[i][0];
          pieces[i].y = tempStates[i][1];
    }
  }
  
  public void switchStateToBeChecked(int[][] tempStates, int xDisplacement, int yDisplacement){
    for(int i = 0; i < tempStates.length; i++){ //switches future state position
        tempStates[i][0] += xDisplacement;
        tempStates[i][1] += yDisplacement;
    }
  }
  
  public boolean checkCurrentPosition(int[][] tempStates, int xDisplacement, int yDisplacement){
    switchStateToBeChecked(tempStates, xDisplacement, yDisplacement); //changes to the current position

    if (isValidFutureState(tempStates)){ //checks if current position is valid
      updateFutureStates(tempStates);
      return true;
    } else{
      return false;
    }
  }
  
  public int[][] getState(char position){
    int[][] stateR = {{pieces[2].x + 1, pieces[2].y - 1}, {pieces[2].x, pieces[2].y - 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y + 1}};
    int[][] state2 = {{pieces[2].x + 1, pieces[2].y + 1}, {pieces[2].x + 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x - 1, pieces[2].y}};
    int[][] stateL = {{pieces[2].x - 1, pieces[2].y + 1}, {pieces[2].x, pieces[2].y + 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y - 1}};
    int[][] state0 = {{pieces[2].x - 1, pieces[2].y - 1}, {pieces[2].x - 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x + 1, pieces[2].y}};
    
    if(position == 'R'){
      return stateR;
    } else if (position == '2'){
      return state2;
    } else if (position == 'L'){
      return stateL;
    } else{ //Case for getting position 0 (default case)
      return state0;
    }
  }
  
  public int[][] getDisplacement(String direction, char futurePosition){
    int[][] fromAnyToR = {{0, 0}, {-1, 0}, {0, -1}, {1, 3}, {-1, 0}};
    int[][] fromRToAny = {{0, 0}, {1, 0}, {0, 1}, {-1, -3}, {1, 0}};
    int[][] fromAnyToL = {{0, 0}, {1, 0}, {0, -1}, {-1, 3}, {1, 0}};
    int[][] fromLToAny = {{0, 0}, {-1, 0}, {0, 1}, {1, -3}, {-1, 0}};
    
    if(futurePosition == 'R'){
      return fromAnyToR;
    } else if(futurePosition == 'L'){
      return fromAnyToL;
    } else if((direction == "CW" && futurePosition == '2') || (direction == "CCW" && futurePosition == '0')){
      return fromRToAny;
    } else{ //Case for CW and 0, or CCW and 2 (default case)
      return fromLToAny;
    }
  }
  
  public void rotatePiece(String direction){
    int[][] futureState = getState(allStates[currState]); //gets the future state of all of the pieces
    int[][] xyTests = getDisplacement(direction, allStates[currState]); //gets the displacements to test all positions of the future state
    
    for(int i = 0; i < xyTests.length; i++){
      if(checkCurrentPosition(futureState, xyTests[i][0], xyTests[i][1])){  //checks if any of the 5 test positions are valid
        return;
      }
    }
  }
  
  public void rotateCW(){
    currState = (currState + 1) % allStates.length;  //updates the current state of the piece
    rotatePiece("CW");
  }
    
  public void rotateCCW(){
    currState = (currState - 1 + allStates.length) % allStates.length;  //updates the current state of the piece
    rotatePiece("CCW");
  }
}
class L_Piece extends Tetromino{ 
  /*For L piece: 
      pieces[2] = Center
      
      State '0':                State 'R':                 State '2':                    State 'L':
      pieces[0] = Top right     pieces[0] = Bottom right   pieces[0] = Bottom left       pieces[0] = Top left
      pieces[1] = Right         pieces[1] = Bottom         pieces[1] = Left              pieces[1] = Top
      pieces[3] = Left          pieces[3] = Top            pieces[3] = Right             pieces[3] = Bottom
  */ 
  L_Piece(int[][] xyCoords){
    super(xyCoords);
    for(Mino p: pieces){
      p.setColor(255, 125, 0);
    }
  }
  
  public boolean isValidFutureState(int[][] tempStates){
    for(int i = 0; i < tempStates.length; i++){ //testing the current position
        if (tempStates[i][0] < 0 || tempStates[i][0] >= cols || tempStates[i][1] < 0 || tempStates[i][1] >= rows){
          return false;
        }
        if (grid[tempStates[i][0]][tempStates[i][1]].isSolid){
          return false;
        }
      }
    return true;
  }
  
  public void updateFutureStates(int[][] tempStates){
    for(int i = 0; i < tempStates.length; i++){ //updates state of all pieces
          pieces[i].x = tempStates[i][0];
          pieces[i].y = tempStates[i][1];
    }
  }
  
  public void switchStateToBeChecked(int[][] tempStates, int xDisplacement, int yDisplacement){
    for(int i = 0; i < tempStates.length; i++){ //switches future state position
        tempStates[i][0] += xDisplacement;
        tempStates[i][1] += yDisplacement;
    }
  }
  
  public boolean checkCurrentPosition(int[][] tempStates, int xDisplacement, int yDisplacement){
    switchStateToBeChecked(tempStates, xDisplacement, yDisplacement); //changes to the current position

    if (isValidFutureState(tempStates)){ //checks if current position is valid
      updateFutureStates(tempStates);
      return true;
    } else{
      return false;
    }
  }
  
  public int[][] getState(char position){
    int[][] stateR = {{pieces[2].x + 1, pieces[2].y + 1}, {pieces[2].x, pieces[2].y + 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y - 1}};
    int[][] state2 = {{pieces[2].x - 1, pieces[2].y + 1}, {pieces[2].x - 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x + 1, pieces[2].y}};
    int[][] stateL = {{pieces[2].x - 1, pieces[2].y - 1}, {pieces[2].x, pieces[2].y - 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y + 1}};
    int[][] state0 = {{pieces[2].x + 1, pieces[2].y - 1}, {pieces[2].x + 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x - 1, pieces[2].y}};
    
    if(position == 'R'){
      return stateR;
    } else if (position == '2'){
      return state2;
    } else if (position == 'L'){
      return stateL;
    } else{ //Case for getting position 0 (default case)
      return state0;
    }
  }
  
  public int[][] getDisplacement(String direction, char futurePosition){
    int[][] fromAnyToR = {{0, 0}, {-1, 0}, {0, -1}, {1, 3}, {-1, 0}};
    int[][] fromRToAny = {{0, 0}, {1, 0}, {0, 1}, {-1, -3}, {1, 0}};
    int[][] fromAnyToL = {{0, 0}, {1, 0}, {0, -1}, {-1, 3}, {1, 0}};
    int[][] fromLToAny = {{0, 0}, {-1, 0}, {0, 1}, {1, -3}, {-1, 0}};
    
    if(futurePosition == 'R'){
      return fromAnyToR;
    } else if(futurePosition == 'L'){
      return fromAnyToL;
    } else if((direction == "CW" && futurePosition == '2') || (direction == "CCW" && futurePosition == '0')){
      return fromRToAny;
    } else{ //Case for CW and 0, or CCW and 2 (default case)
      return fromLToAny;
    }
  }
  
  public void rotatePiece(String direction){
    int[][] futureState = getState(allStates[currState]); //gets the future state of all of the pieces
    int[][] xyTests = getDisplacement(direction, allStates[currState]); //gets the displacements to test all positions of the future state
    
    for(int i = 0; i < xyTests.length; i++){
      if(checkCurrentPosition(futureState, xyTests[i][0], xyTests[i][1])){  //checks if any of the 5 test positions are valid
        return;
      }
    }
  }
  
  public void rotateCW(){
    currState = (currState + 1) % allStates.length;  //updates the current state of the piece
    rotatePiece("CW");
  }
    
  public void rotateCCW(){
    currState = (currState - 1 + allStates.length) % allStates.length;  //updates the current state of the piece
    rotatePiece("CCW");
  }
}
class Mino{
  int x, y;
  int r = 0;
  int g = 0;
  int b = 0;
  boolean isSolid = false;
  
  Mino(int _x, int _y){
    x = _x;
    y = _y;
  }
  
  public void setColor(int _r, int _g, int _b){
    r = _r;
    g = _g;
    b = _b;
  }
  
  public void show(){
    fill(r, g, b, 205);
    strokeWeight(2);
    square(xStartPos + x*cellSize, yStartPos + y*cellSize, cellSize);
  }
  
  public void showOutsideGrid(int xPos, int yPos){
    fill(r, g, b);
    strokeWeight(2);
    square(xPos, yPos, cellSize);
  }
  
  public void move(int xDist, int yDist){
    x += xDist;
    y += yDist;
  }
  
  public void copyMinoValues(Mino toCopy){
    r = toCopy.r;
    g = toCopy.g;
    b = toCopy.b;
    isSolid = toCopy.isSolid;
  }
  
  public void resetValues(){
    isSolid = false;
    setColor(0, 0, 0);
  }
}
class O_Piece extends Tetromino{
  /*For O Piece:
    pieces[0] = Top left
    pieces[1] = Top right
    pieces[2] = Bottom left
    pieces[3] = Bottom right
    No rotations to do here (I don't want to code in that mess of an O spin)
  */
  O_Piece(int[][] xyCoords){
    super(xyCoords);
    for(Mino p: pieces){
      p.setColor(255, 255, 0);
    }
  }
}
class S_Piece extends Tetromino{ 
  /*For S piece: 
      pieces[2] = Center
      
      State '0':                State 'R':                 State '2':                    State 'L':
      pieces[0] = Top right     pieces[0] = Bottom Right   pieces[0] = Bottom Left       pieces[0] = Top left
      pieces[1] = Top           pieces[1] = Right          pieces[1] = Bottom            pieces[1] = Left
      pieces[3] = Left          pieces[3] = Top            pieces[3] = Right             pieces[3] = Bottom
  */ 
  S_Piece(int[][] xyCoords){
    super(xyCoords);
    for(Mino p: pieces){
      p.setColor(0, 255, 0);
    }
  }
  
  public boolean isValidFutureState(int[][] tempStates){
    for(int i = 0; i < tempStates.length; i++){ //testing the current position
        if (tempStates[i][0] < 0 || tempStates[i][0] >= cols || tempStates[i][1] < 0 || tempStates[i][1] >= rows){
          return false;
        }
        if (grid[tempStates[i][0]][tempStates[i][1]].isSolid){
          return false;
        }
      }
    return true;
  }
  
  public void updateFutureStates(int[][] tempStates){
    for(int i = 0; i < tempStates.length; i++){ //updates state of all pieces
          pieces[i].x = tempStates[i][0];
          pieces[i].y = tempStates[i][1];
    }
  }
  
  public void switchStateToBeChecked(int[][] tempStates, int xDisplacement, int yDisplacement){
    for(int i = 0; i < tempStates.length; i++){ //switches future state position
        tempStates[i][0] += xDisplacement;
        tempStates[i][1] += yDisplacement;
    }
  }
  
  public boolean checkCurrentPosition(int[][] tempStates, int xDisplacement, int yDisplacement){
    switchStateToBeChecked(tempStates, xDisplacement, yDisplacement); //changes to the current position

    if (isValidFutureState(tempStates)){ //checks if current position is valid
      updateFutureStates(tempStates);
      return true;
    } else{
      return false;
    }
  }
  
  public int[][] getState(char position){
    int[][] stateR = {{pieces[2].x + 1, pieces[2].y + 1}, {pieces[2].x + 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y - 1}};
    int[][] state2 = {{pieces[2].x - 1, pieces[2].y + 1}, {pieces[2].x, pieces[2].y + 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x + 1, pieces[2].y}};
    int[][] stateL = {{pieces[2].x - 1, pieces[2].y - 1}, {pieces[2].x - 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y + 1}};
    int[][] state0 = {{pieces[2].x + 1, pieces[2].y - 1}, {pieces[2].x, pieces[2].y - 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x - 1, pieces[2].y}};
    
    if(position == 'R'){
      return stateR;
    } else if (position == '2'){
      return state2;
    } else if (position == 'L'){
      return stateL;
    } else{ //Case for getting position 0 (default case)
      return state0;
    }
  }
  
  public int[][] getDisplacement(String direction, char futurePosition){
    int[][] fromAnyToR = {{0, 0}, {-1, 0}, {0, -1}, {1, 3}, {-1, 0}};
    int[][] fromRToAny = {{0, 0}, {1, 0}, {0, 1}, {-1, -3}, {1, 0}};
    int[][] fromAnyToL = {{0, 0}, {1, 0}, {0, -1}, {-1, 3}, {1, 0}};
    int[][] fromLToAny = {{0, 0}, {-1, 0}, {0, 1}, {1, -3}, {-1, 0}};
    
    if(futurePosition == 'R'){
      return fromAnyToR;
    } else if(futurePosition == 'L'){
      return fromAnyToL;
    } else if((direction == "CW" && futurePosition == '2') || (direction == "CCW" && futurePosition == '0')){
      return fromRToAny;
    } else{ //Case for CW and 0, or CCW and 2 (default case)
      return fromLToAny;
    }
  }
  
  public void rotatePiece(String direction){
    int[][] futureState = getState(allStates[currState]); //gets the future state of all of the pieces
    int[][] xyTests = getDisplacement(direction, allStates[currState]); //gets the displacements to test all positions of the future state
    
    for(int i = 0; i < xyTests.length; i++){
      if(checkCurrentPosition(futureState, xyTests[i][0], xyTests[i][1])){  //checks if any of the 5 test positions are valid
        return;
      }
    }
  }
  
  public void rotateCW(){
    currState = (currState + 1) % allStates.length;  //updates the current state of the piece
    rotatePiece("CW");
  }
    
  public void rotateCCW(){
    currState = (currState - 1 + allStates.length) % allStates.length;  //updates the current state of the piece
    rotatePiece("CCW");
  }
}
class T_Piece extends Tetromino{ 
  /*For T piece: 
      pieces[2] = Center
      
      State '0':                State 'R':                     State '2':                State 'L':
        pieces[0] = Top           pieces[0] = Top middle         pieces[0] = Bottom        pieces[0] = Top middle
        pieces[1] = Left          pieces[1] = Bottom middle      pieces[1] = Left          pieces[1] = Left
        pieces[3] = Right         pieces[3] = Right              pieces[3] = Right         pieces[3] = Bottom middle
  */
  T_Piece(int[][] xyCoords){
    super(xyCoords);
    for(Mino p: pieces){
      p.setColor(255, 0, 255);
    }
  }
  
  public boolean isValidFutureState(int[][] tempStates){
    for(int i = 0; i < tempStates.length; i++){ //testing the current position
        if (tempStates[i][0] < 0 || tempStates[i][0] >= cols || tempStates[i][1] < 0 || tempStates[i][1] >= rows){
          return false;
        }
        if (grid[tempStates[i][0]][tempStates[i][1]].isSolid){
          return false;
        }
      }
    return true;
  }
  
  public void updateFutureStates(int[][] tempStates){
    for(int i = 0; i < tempStates.length; i++){ //updates state of all pieces
          pieces[i].x = tempStates[i][0];
          pieces[i].y = tempStates[i][1];
    }
  }
  
  public void switchStateToBeChecked(int[][] tempStates, int xDisplacement, int yDisplacement){
    for(int i = 0; i < tempStates.length; i++){ //switches future state position
        tempStates[i][0] += xDisplacement;
        tempStates[i][1] += yDisplacement;
    }
  }
  
  public boolean checkCurrentPosition(int[][] tempStates, int xDisplacement, int yDisplacement){
    switchStateToBeChecked(tempStates, xDisplacement, yDisplacement); //changes to the current position

    if (isValidFutureState(tempStates)){ //checks if current position is valid
      updateFutureStates(tempStates);
      return true;
    } else{
      return false;
    }
  }
  
  public int[][] getState(char position){
    int[][] stateR = {{pieces[2].x, pieces[2].y - 1}, {pieces[2].x, pieces[2].y + 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x + 1, pieces[2].y}};
    int[][] state2 = {{pieces[2].x, pieces[2].y + 1}, {pieces[2].x - 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x + 1, pieces[2].y}};
    int[][] stateL = {{pieces[2].x, pieces[2].y - 1}, {pieces[2].x - 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y + 1}};
    int[][] state0 = {{pieces[2].x, pieces[2].y - 1}, {pieces[2].x - 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x + 1, pieces[2].y}};
    
    if(position == 'R'){
      return stateR;
    } else if(position == '2'){
      return state2;
    } else if(position == 'L'){
      return stateL;
    } else{
      return state0;
    }
  }
  
  public int[][] getDisplacement(String direction, char futurePosition){
    int[][] fromAnyToR = {{0, 0}, {-1, 0}, {0, -1}, {1, 3}, {-1, 0}};
    int[][] fromRToAny = {{0, 0}, {1, 0}, {0, 1}, {-1, -3}, {1, 0}};
    int[][] fromAnyToL = {{0, 0}, {1, 0}, {0, -1}, {-1, 3}, {1, 0}};
    int[][] fromLToAny = {{0, 0}, {-1, 0}, {0, 1}, {1, -3}, {-1, 0}};
    
    if(futurePosition == 'R'){
      return fromAnyToR;
    } else if(futurePosition == 'L'){
      return fromAnyToL;
    } else if((direction == "CW" && futurePosition == '2') || (direction == "CCW" && futurePosition == '0')){
      return fromRToAny;
    } else{ //Case for CW and 0, or CCW and 2 (default case)
      return fromLToAny;
    }
  }
  
  public void rotatePiece(String direction){
    int[][] futureState = getState(allStates[currState]); //gets the future state of all of the pieces
    int[][] xyTests = getDisplacement(direction, allStates[currState]); //gets the displacements to test all positions of the future state
    
    for(int i = 0; i < xyTests.length; i++){
      //checks if any of the 5 test positions are valid
      if(checkCurrentPosition(futureState, xyTests[i][0], xyTests[i][1])){ 
        return;
      }
    }
  }
  
  public void rotateCW(){
    //updates the current state of the piece
    currState = (currState + 1) % allStates.length;
    rotatePiece("CW");
  }
    
  public void rotateCCW(){
    //updates the current state of the piece
    currState = (currState - 1 + allStates.length) % allStates.length;
    rotatePiece("CCW");
  }
}
class Tetromino{
  Mino[] pieces = new Mino[4];
  boolean isLocked = false;
  int countdown = 2;
  char[] allStates = {'0', 'R', '2', 'L'};
  int currState = 0;
  int[][] startPos = new int[4][2];
  
  //Makes 4 minos connected to each other
  Tetromino(int[][] xyCoords){
    for(int i = 0; i < xyCoords.length; i++){
      pieces[i] = new Mino(xyCoords[i][0], xyCoords[i][1]);
      pieces[i].isSolid = true;
      startPos[i][0] = xyCoords[i][0];
      startPos[i][1] = xyCoords[i][1];
    }
  }
  
  public void show(){
    for(Mino p: pieces){
      p.show();
    }
  }
  
  public void resetPosition(){
    for(int i = 0; i < startPos.length; i++){
      pieces[i].x = startPos[i][0];
      pieces[i].y = startPos[i][1];
    }
  }
  
  public void showOutsideGrid(int xPos, int yPos){
    for(Mino p: pieces){
      p.showOutsideGrid(xPos + p.x*cellSize, yPos + p.y*cellSize);
    }
  }
  
  //Checks if the current piece is on solid ground
  public boolean isValidYState(){
    boolean isNotOnSolidGround = true;
    for(Mino p: pieces){
      if(p.y < rows - 1){
        if (grid[p.x][p.y + 1].isSolid){
          isNotOnSolidGround = false;
          break;
        }
      } else{
        isNotOnSolidGround = false;
        break;
      }
    }
    return isNotOnSolidGround;
  }
  
  //updates the y position of the piece
  public void update(){
    if(!isLocked && isValidYState() && countdown > 0){
      for(Mino p: pieces){
        p.move(0, 1);
      }
      if (countdown < 2){
        countdown++;
      }
    } else if(countdown > 0){
      countdown--;
    } else{
      hardDrop();
    }
  }
  
  //drops the piece faster
  public void softDrop(){
    if(!isLocked && isValidYState() && countdown > 0){
      for (Mino p: pieces){
        p.move(0, 1);
      }
      pieceDropRate += softDropRate;
      if (countdown < 2){
        countdown++;
      }
    } else if (countdown > 0){
      countdown--;
    } else{
      isLocked = true;
    }
  }
  
  //drops the piece to the current highest point directly below the piece
  public void hardDrop(){
    pieceDropRate = pieceDropLimit;
    int yDist = rows - 1;
    
    if(!isLocked && isValidYState()){ //checks if there is enough space below the piece to hard drop
      for(Mino p: pieces){ //finds the smallest distance between the piece and the "floor" (not only the floor)
        int currLowestNonSolidY = p.y;
        //checks each row if the current cell is not solid (starts from the cell directly below it)
        for(int i = p.y + 1; i < rows; i++){  
          if (!grid[p.x][i].isSolid){
            currLowestNonSolidY++;
          } else{
            break;
          }
        }
        yDist = min(yDist, currLowestNonSolidY - p.y); //takes the smallest distance available
      }
      for(Mino p: pieces){
          p.move(0, yDist);
      }
    }
    isLocked = true;
  }
  
  //moves piece to the right
  public void moveRight(){
    if(!isLocked){
      int rightMostX = 0;
      int rightMostY = 0;
      for(Mino p: pieces){
        if(rightMostX < p.x){
          rightMostX = p.x;
          rightMostY = p.y;
        }
      }
      if(rightMostX < cols - 1){
        for(Mino p: pieces){ //checks if there are any solid minos to the right of the piece
          if (grid[p.x + 1][p.y].isSolid){
            return;
          }
        }
        if(!grid[rightMostX + 1][rightMostY].isSolid){
          for(Mino p: pieces){
            p.move(1, 0);
          }
        }
      }
    }
  }
  
  //moves piece to the left
  public void moveLeft(){
    if(!isLocked){
      int leftMostX = 20;
      int leftMostY = 0;
      for(Mino p: pieces){
        if (leftMostX > p.x){
          leftMostX = p.x;
          leftMostY = p.y;
        }
      }
      if (leftMostX > 0){
        for(Mino p: pieces){ //checks if there are any solid minos to the left of the piece
          if (grid[p.x - 1][p.y].isSolid){
            return;
          }
        }
        if(!grid[leftMostX - 1][leftMostY].isSolid){
          for (Mino p: pieces){
            p.move(-1, 0);
          }
        }
      }
    }
  }
  
  public void rotateCW(){
    //This is only here as a placeholder to prevent superclass errors, each piece has this actually filled out
  }
  
  public void rotateCCW(){
    //This is only here as a placeholder to prevent superclass errors, each piece has this actually filled out
  }
}
class Z_Piece extends Tetromino{ 
  /*For Z piece: 
      pieces[2] = Center
      
      State '0':                State 'R':                 State '2':                    State 'L':
      pieces[0] = Top left      pieces[0] = Top right      pieces[0] = Bottom right      pieces[0] = Bottom left
      pieces[1] = Top           pieces[1] = Right          pieces[1] = Bottom            pieces[1] = Left
      pieces[3] = Right         pieces[3] = Bottom         pieces[3] = Left              pieces[3] = Top
  */ 
  Z_Piece(int[][] xyCoords){
    super(xyCoords);
    for(Mino p: pieces){
      p.setColor(255, 0, 0);
    }
  }
  
  public boolean isValidFutureState(int[][] tempStates){
    for(int i = 0; i < tempStates.length; i++){ //testing the current position
        if (tempStates[i][0] < 0 || tempStates[i][0] >= cols || tempStates[i][1] < 0 || tempStates[i][1] >= rows){
          return false;
        }
        if (grid[tempStates[i][0]][tempStates[i][1]].isSolid){
          return false;
        }
      }
    return true;
  }
  
  public void updateFutureStates(int[][] tempStates){
    for(int i = 0; i < tempStates.length; i++){ //updates state of all pieces
          pieces[i].x = tempStates[i][0];
          pieces[i].y = tempStates[i][1];
    }
  }
  
  public void switchStateToBeChecked(int[][] tempStates, int xDisplacement, int yDisplacement){
    for(int i = 0; i < tempStates.length; i++){ //switches future state position
        tempStates[i][0] += xDisplacement;
        tempStates[i][1] += yDisplacement;
    }
  }
  
  public boolean checkCurrentPosition(int[][] tempStates, int xDisplacement, int yDisplacement){
    switchStateToBeChecked(tempStates, xDisplacement, yDisplacement); //changes to the current position

    if (isValidFutureState(tempStates)){ //checks if current position is valid
      updateFutureStates(tempStates);
      return true;
    } else{
      return false;
    }
  }
  
  public int[][] getState(char position){
    int[][] stateR = {{pieces[2].x + 1, pieces[2].y - 1}, {pieces[2].x + 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y + 1}};
    int[][] state2 = {{pieces[2].x + 1, pieces[2].y + 1}, {pieces[2].x, pieces[2].y + 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x - 1, pieces[2].y}};
    int[][] stateL = {{pieces[2].x - 1, pieces[2].y + 1}, {pieces[2].x - 1, pieces[2].y}, {pieces[2].x, pieces[2].y}, {pieces[2].x, pieces[2].y - 1}};
    int[][] state0 = {{pieces[2].x - 1, pieces[2].y - 1}, {pieces[2].x, pieces[2].y - 1}, {pieces[2].x, pieces[2].y}, {pieces[2].x + 1, pieces[2].y}};
    
    if(position == 'R'){
      return stateR;
    } else if (position == '2'){
      return state2;
    } else if (position == 'L'){
      return stateL;
    } else{ //Case for getting position 0 (default case)
      return state0;
    }
  }
  
  public int[][] getDisplacement(String direction, char futurePosition){
    int[][] fromAnyToR = {{0, 0}, {-1, 0}, {0, -1}, {1, 3}, {-1, 0}};
    int[][] fromRToAny = {{0, 0}, {1, 0}, {0, 1}, {-1, -3}, {1, 0}};
    int[][] fromAnyToL = {{0, 0}, {1, 0}, {0, -1}, {-1, 3}, {1, 0}};
    int[][] fromLToAny = {{0, 0}, {-1, 0}, {0, 1}, {1, -3}, {-1, 0}};
    
    if(futurePosition == 'R'){
      return fromAnyToR;
    } else if(futurePosition == 'L'){
      return fromAnyToL;
    } else if((direction == "CW" && futurePosition == '2') || (direction == "CCW" && futurePosition == '0')){
      return fromRToAny;
    } else{ //Case for CW and 0, or CCW and 2 (default case)
      return fromLToAny;
    }
  }
  
  public void rotatePiece(String direction){
    int[][] futureState = getState(allStates[currState]); //gets the future state of all of the pieces
    int[][] xyTests = getDisplacement(direction, allStates[currState]); //gets the displacements to test all positions of the future state
    
    for(int i = 0; i < xyTests.length; i++){
      if(checkCurrentPosition(futureState, xyTests[i][0], xyTests[i][1])){  //checks if any of the 5 test positions are valid
        return;
      }
    }
  }
  
  public void rotateCW(){
    currState = (currState + 1) % allStates.length;  //updates the current state of the piece
    rotatePiece("CW");
  }
    
  public void rotateCCW(){
    currState = (currState - 1 + allStates.length) % allStates.length;  //updates the current state of the piece
    rotatePiece("CCW");
  }
}


  public void settings() { size(900, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Tetris_Clone_attempt" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
